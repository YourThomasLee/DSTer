>   主程序：remix_main

## 执行顺序

### 初始化：remix_init

#### 系统环境初始化：Environment

>   参考remix框架：include/environment.h

*   系统环境初始化

*   系统配置初始化

    *   `init_conf`

    *   `init_modules`

        >   Topo: 遍历每个phase，遍历每个phase下的module
        >
        >   初始化每个phase、每个module
        >
        >   对于交互类，init_service
        >
        >   对于所有类，init_module => 调用所有Module的`DECLEAR_PROC_DATA` （进程级别数据）

    *   初始化yacl，调用`_module_mgr->register_all_confs` => 各module调用`register_conf()`

    *   初始化`xbox_client`

    *   初始化`xbuiltin`，调用`_module_mgr->register_all_dicsts` => 调用各module的`register_dict()`，初始化每个字点

    *   初始化predictor

    *   对phase中的modules进行排序，按从小到大timeout进行wait

    *   Mgr => 添加phase`_module_phase_array`，每个phase添加module`_module_array`

**【DECLEAR_PROC_DATA】**

*   创建当前moduleProcData的对象
*   `proc_data->initialize`
*   GO_ON

#### Reloader.init

*   读取配置文件的重载间隔时间：`&_reload_interval`

    ```
    REGCFG_ITEM(key, val, 类型);
    ```

#### Searcher.init

```c++
RemixSearcher::init(); //RemixSearcher的初始化
    //设置线程数
    REGCFG_ITEM("THREAD_NUM", &_thread_num, CFG_INT); 
    // 创建线程数组，一个线程为一个pthread_t类型
    _thread_array = new(std::nothrow) pthread_t[_thread_num]; 
	// 根据线程数，创建检索环境池，其中将包含thread_num个QueryContext
    _query_context_pool = new(std::nothrow) QueryContextPool(_thread_num);
    _query_context_pool->init(); 
    //初始化每个QueryContext里面的module的query context，数目为_thread_num*_module_num
```

*   **QueryContextPool的实例化**

    *   本质是：QueryContext数组

        >   `_pool_size`是配置

    *   初始化里面每个QueryContext的module检索环境：`mod_mgr->init_mods_query_context`

        >   遍历phase、遍历每个phase里面的module，将每个module都在QueryContext中存储对应数据

        *   `phase->get_module`
        *   `module->allocate_query_context`, 初始化`_status(CONTEXT_AVAILABLE)`和`_ignored`
        *   `q_ctx->set_module_context`

**【DECLEAR_MODULE_QUERY_CONTEXT】**

*   创建当前Module对应的ModBaseQueryContext
*   `q_ctx->init_context`
*   返回`q_ctx`（用于setQueryContext，放入当前QueryContext的modules_data中）

### 启动：remix_start

#### 启动监控ub和sf

*   获取ub监控：`RemixUbMonitor::get_instance()->run()`

#### Reloader.start

*   `reload_thread_foo`

    >   Foo: function object oriented, 面向过程

    *   Reloader自身reload

    *   调用各module的`reload_module_proc_data`

        >   调用各module的`get_proc_data()`

    *   调用各module的`reload_module`

    *   调用`xbuiltin::Manager::instance()`的`reload_dict`

    *   重载yacl

#### Searcher.start

*   **start**：回调函数`search_thread_foo`

*   **search_thread_foo**

    *   获取检索环境`QueryContext`
    *   上游读数据`read_request`
    *   运行所有module`run_all_phases`
    *   将结果写回上游`send_response`

*   **step2：read_request**

    *   获取当前env的tcp连接池
    *   获取交互数据的buffer变量
    *   创建网络连接: client_fd是建立的套接字socket，请求互斥访问
    *   读数据：获取`_nshead_t`（`upstream->_request`），调用`ul_sreado_ms_ex`读取头和body

*   **step3: run_all_phases**

    *   遍历每个phase => `run_modules`

    *   run_modules

        *   交互类

            *   所有类都查看`q_ctx->_allow_reverse`，按耗时大小顺序发送模块`phase->get_response_module(index)` or 原顺序`phase->get_module(index);`
            *   过滤非交互类
            *   获取`ModBaseQueryContext`：`get_self_context`，从当前q_ctx的`modules_data`中取出该module的数据3
            *   查看是否需要忽略模块执行: 基类`module->should_ignore`
            *   `query_contex->prepare_context`
            *   强制转换为交互类
            *   `query_context->create_rpc_channel`
            *   `upstream_module->prepare_request`
            *   `upstream_module->send_request`

        *   非交互类

            *   获取`ModBaseQueryContext`

            *   查看是否需要忽略模块执行: 基类`module->should_ignore`

                >   若ignore，continue，进行下一个非交互类的操作

            *   `query_contex->prepare_context`

            *   强制转换module为非交互类，调用`filter_module->handle_data`

                >   调用完要设置`_status`为`CONTEXT_UNAVAILABLE`

            *   判断是否需要`debugpf`，需要则`module->record_debugpf_info`

                >   Debugpf: debug platform，是否使用debug平台

        *   交互类

            *   获取`ModBaseQueryContext`
            *   `upstream_module->wait_response`
            *   `upstream_module->handle_response`
            *   `upstream_module->close_rpc_channel`
            *   判断是否需要`debugpf`，需要则`module->record_debugpf_info`

*   **step4: send_response**

    *   获取交互数据`upstream_data`
    *   获取response数据（`upstream->_response`）
    *   写回上游，用`nshead_write`写

### 等待终止信号

### 停止：remix_stop

*   **sf监控停止**
*   **Reloader.stop**
    *   `_is_exit`设为true
    *   杀死线程
    *   pthread等待
*   **Searcher.stop**
    *   获取env的tcp连接池
    *   等待所有线程终止：过程中不断将未成功join的线程输出到日志

### 资源回收：remix_uninit

*   **Reloader.finalize**: 返回0
*   **Searcher.finalize**
    *   终结当前searcher的检索环境池
    *   回收检索环境池和线程数组的内存
*   **ENV实例的finalize**
    *   终结xbobx、module、ioc容器、tcp连接池
*   **删除ENV实例**

## 拓扑结构

<img src="http://bj.bcebos.com/ibox-thumbnail98/0bdd88bcb637f9218720eef3f7a5b57f?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-28T09%3A11%3A36Z%2F1800%2F%2F997bd1522c7ed3cea2e0c55fcbb737b5cf4a35b28ebbf47c0278d8dddae22aa2">

<img src="http://bj.bcebos.com/ibox-thumbnail98/416ba265a34d58637d54d086872b3b62?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-21T09%3A29%3A58Z%2F1800%2F%2F450acf3157a19f3e8f34bbefa57b3d4cb4ef2bff2375286078ae1d9b0ca28310">

* 阶段1
  * DataManagerModule
* 阶段2
  * ReqProcessModule
  * LiteSearchRedis
* 阶段3
  * LiteGoldengateSendProcessModule
  * LiteIntentServiceSendProcessModule
  * PaBdrpProcessModule

* 阶段4

  * FeedbesXboxModule：xbox获取用户特征
  * UnionidProcessModule：用于rta
  * FeedUserXboxCenterModule
  * UasProcessModule
  * UserCenterProcessModule
  * UpinProcessModule
  * KaiwuProcessModule
  * LiteKaiwuProcessModule：kaiwu信息
  * UmsProcessModule：attention信息，短期兴趣、dislike兴趣
  * LiteGoldengateProcessModule
  * IntentServiceProcessModule
  * RtaserverProcessModule

* 阶段5

  * PdsUserqRecvModule

  * FLProcessModule: fugue-lite的启动和等待

    > Fugue: 基于DAG的编程框架，提供并行、流式、异步的执行引擎，旨在提升检索速度

  * FeedRtaReadModule

* 阶段6

  * GoldegateProcessModule
  * UserEmbeddingProcessModule
  * RedisProcessModule
  * XboxCenterProcessModule
  * PaPreProcessModule

* 阶段7

  * FLEndProcessModule

* 阶段8

  * LiteGoldengateRecvProcessModule
  * LiteIntentServiceRecvProcessModule

* 阶段9

  * QueryProcessModule

* 阶段10

  * PatProcessModule
  * FeedProxyProcessModule
  * RtaBsProcessModule
  * BesRtaBsProcessModule

* 阶段11

  * PaAdrestProcessModule
  * AdrestProcessModule
  * FeedAdrestXboxModule
  * MaterialProcessModule

* 阶段12

  * PaPostProcessModule

* 阶段13

  * StrategyProcessModule

* 阶段14

  * PostProcessModule

* 阶段15

  * ResponseProcessModule

## 日志类型

*   CFATAL_LOG

*   CWARNING_LOG

    
