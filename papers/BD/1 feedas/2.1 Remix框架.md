## Remix概述

> ref: [Remix模块概述](https://console.cloud.baidu-int.com/devops/icode/repos/baidu/im-common/remix/tree/master:docs)

* **def**：通用的proxy-server框架
* **目标**
  * 组件式开发和自定义配置驱动，实现业务和后端模块交互的串并行处理
  * 默认支持pbrpc/nshead itp等后端服务接入，应用层只负责填充request和解析response，分库/交互等由框架默认托管实现

## Modules介绍

> Ref: [Modules介绍](http://wiki.baidu.com/pages/viewpage.action?pageId=207029547)

* `def`：Remix框架中真正实现业务逻辑的部分

### 配置文件`modules.conf`

#### 职责

* 负责Module的初始化和加载
* 每个Module通过唯一的identifier进行标识，并维持各自的索引号index（自增）

#### 数据结构ModuleMgr

> 类似二维数组
>
> 实现组间串行，组内并行

* 第一维是Phase，每个phase之间管理多个Module
* `run_phases`中，各个phase之间串行
* 每个Phase的`run_modules`中，module之间并行 (尽量并行，不是真正意义的并行)

#### topo结构

<img src="http://bj.bcebos.com/ibox-thumbnail98/e68179ad387345b507f20fbc63950bca?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-22T06%3A49%3A30Z%2F1800%2F%2F857882c4037ef87a241deea70af9caf77e4214c77babca6a46eacfe668d99f0d" style="zoom:50%;" >

### Module的类型

> ref: [Remix文档](https://console.cloud.baidu-int.com/devops/icode/repos/baidu/im-common/remix/blob/master:docs/03_ModuleIntroduction.md)

#### 类的结构

* 基类：BaseModule

    >   每个BaseModule的配套数据 = 进程数据ModBaseProcData + 检索环境ModBaseQueryContext

* 子类1：非交互类`FilterModule`

* 子类2：交互类`UpstreamBaseModule`

  > 包括ItpBaseModule和PbrpcBaseModule，前者支持nshead+itp协议，后者支持hulu-pbrpc协议

<img src="http://bj.bcebos.com/ibox-thumbnail98/2b13af110421c63157f3f9ade203e283?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-22T06%3A51%3A07Z%2F1800%2F%2Fb1a00683eb49f222834ee73c19683c42296d97c3d263f7256f08a8c5e5217f49" style="zoom:50%;" >

> #表示protected类型

#### 非交互类：FileterModule

* 入口函数是`handle_data`
* 作用：支持简单的业务规则处理

#### 交互类：UpstreamModule

* **作用**：支持后端服务的交互

* **实现步骤**

  * create_rpc_channel: 如果需要选择特定后端时子类才实现，否则默认随机选取后端
  * prepare_request和handle_response为必须实现
  * send_request: pdrpc子类实现(`DECLARE_RPC_SEND_REQUEST_METHOD`) + rawbuffer由基类默认实现
  * wait_response & close_rpc_channel：默认由基类实现

  <img src="http://bj.bcebos.com/ibox-thumbnail98/bdc49c92223f44a33dbefc02010ae53b?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-22T06%3A56%3A14Z%2F1800%2F%2F32a53bb39e3b7c65a0dd92652e5f80feb8b9b3324f3cf41cd1958753ca5c7ced" style="zoom:50%;" >

* **使用方法**

  * 一般情况，业务类实现`prepare_request`和`handle_response`即可

  * 如果需要指定下游交互的service，则可以重写`create_rpc_channel`

#### 运行机制

* **串行phase**

  > <img src="http://bj.bcebos.com/ibox-thumbnail98/c66f83ea2232fd18113df5bfd395ea7f?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-27T06%3A21%3A44Z%2F1800%2F%2Fe11a56ce651a3f37c25b63b14df1ee3369314b8c78851ff5d22f502116571d72" style="zoom:50%;" >

* **并行module**

  ```c++
  run_modules(Environment *env, QueryContext *q_ctx, ModulePhase *phase)
  {
  //为了最大限度的提高并行度和使得交互类持有句柄的时间尽可能的短，phase内部按照如下顺序执行：
  //1、对交互类Module执行句柄申请、请求构造和发送
  for(int index=0; index<phase->size(); ++index)
  {
  BaseModule* module = phase->get_module(index);
  if (module == NULL || module->get_module_type() !=  MODULE_TYPE_UPSTREAM)
  continue;
   
  ModBaseQueryContext * queryContex  = module->get_self_context(q_ctx);
  queryContext->prepareContext();
  queryContext->create_rpc_channel();
  queryContext->send_request();
  }
  //2、对非交互类调用处理接口
  for(int index = 0; index<phase->size(); ++index)
  {
  BaseModule* moudule = phase->get_module(index);
  if (module == NULL  || module->get_module_type != MODULE_TYPE_FILTER)
  continue;
  ModBaseQueryContext* queryContext = get_self_context(module);
  queryContext->handle_data();
  }
  //3、等待交互类结果，处理响应和句柄释放
  for (int index = 0; index < phase->size(); ++index)
  {
  BaseModule* module = phase->get_module(index);
  if (module == NULL || module->get_module_type != MODULE_TYPE_UPSTREAM)
  continue;
   
  ModBaseQueryContext* queryContext = module->get_self_context();
  queryContext->wait_response();
  queryContext->handle_response();
  queryContext->close_rpc_channel();
  }
  }
  ```

  

#### 两个子类的并行实现 | 执行顺序

* 先执行交互类的`create_rpc_channel`、`prepare_request`、`send_request`
* 交互时，执行非交互类的`handle_data`
* 最后执行`handle_response`

<img src="http://bj.bcebos.com/ibox-thumbnail98/b7424ae7c925536d2d69b3928f31ad88?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-22T07%3A01%3A00Z%2F1800%2F%2Ff136b675069319380202eb9885d9b5149b3fb94b9416acb5a4237160f1212ee1" style="zoom:50%;" >

## Remix main

> Ref: [Remix main](http://wiki.baidu.com/display/~zhaojing24/Remix+main)

* **入口函数**：`remix_main()`

* **运行机制**

  <img src="http://bj.bcebos.com/ibox-thumbnail98/5d49028ef4cefee54914756cbde76108?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T02%3A51%3A26Z%2F1800%2F%2Ff798b0a99a19c6069fba3ef0c3f7409d337988236e5f210da386c8a6e713ec84" style="zoom: 60%;" >

  * remix初始化: 系统环境初始化 + RemixReloader初始化 + RemixSearcher初始化

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/bb1fe45a77f5823196a9657d657590c4?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T03%3A32%3A09Z%2F1800%2F%2F1e0c2553fb129fa512ae1810a0f507a3e8d7ef8d034c9cfb002e161f63242287" style="zoom:50%;" >

  * 框架启动运行: 启动监控 + 启动Reloader和Searcher

    > <img src="https://gitee.com/WIN0624/document/raw/master/img/image-20210723113623532.png" alt="image-20210723113623532" style="zoom:50%;" />

  * 等待结束信号

  * remix停止运行：sf监控停止 + Reloader&Searcher监控停止

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/f71fde66e865129dbb0a8af249dd662b?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T03%3A41%3A28Z%2F1800%2F%2F1c2c9e85fdc96ed418b4aff8967ac20d6521f800574bbacf2f9933645a7c2e68" style="zoom:50%;" >

  * 系统回收资源：回收Reloader&Searcher&`Environment`

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/06e6089e9b98da6f6277e7816ddb2b26?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T03%3A42%3A07Z%2F1800%2F%2F7532a2a7e78aeeb1d244a74cb40b69e04909246586ca6738545427fe093d8329" style="zoom:50%;" >

## Remix Reloader

> ref: [Remix Reloader](http://wiki.baidu.com/display/~zhaojing24/Remix+Reloader)

* **作用**：重新加载配置项

  > 系统每隔一段时间需要去检查配置项文件的状态，如果更新了，就要重新读取配置文件内容，对各项配置进行更新

* **运行机制**：start启动线程

  * while循环，接收结束信号才停止
  * 循环内通过sleep控制间隔
  * 读取配置文件
  * 重新加载module进程数据：`reload_proc_data`
  * 重新读取module：`reload_modules`

<img src="http://bj.bcebos.com/ibox-thumbnail98/87248ba9bccffd27dc50bace60ba7f88?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T03%3A58%3A09Z%2F1800%2F%2F67bc69a8bd506968a2af60502773cc671d4a28cd054f4d36d03761fd16867345">

## Remix Searcher

> Ref: [Remix Searcher](http://wiki.baidu.com/display/~zhaojing24/Remix+Searcher)

* **作用**：检索服务框架，负责系统的核心功能

* **运行机制**

  * 开启多个线程执行检索服务，每个线程一次处理一条检索请求

  * 每个Searcher需要维护自己的线程，因此会记录：`线程数目thread_num`，`线程数组thread_array`和`线程检索环境池，queryContextPool`

    > Pool是个数组，里面维持着多个检索环境QueryContext，即每个线程有一个自己的QueryContext

* **检索框架**

  <img src="http://bj.bcebos.com/ibox-thumbnail98/35fada0c610123d31660819475357573?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T04%3A01%3A50Z%2F1800%2F%2F29f61f423c93d694ab7766af8169fcb9c1d964c61ff1e63260285836b09781a7" style="zoom:50%;" >

  * **init**：读取配置文件中的线程数量，为线程数组和检索环境池分配空间

  * **finalize**：释放和回收检索环境池和线程数组的资源

  * **stop**：遇到结束信号`_is_exit`，等待所有线程并退出

  * **start**：创建多线程执行检索

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/d69f3941ff4ea654109a44d0f5e2a648?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T06%3A15%3A05Z%2F1800%2F%2F9330758e7e55d020a3c171aa7623f35596d25d17ab76d80a153401bc39c5ed89">

    * Search_thread_foo

      > <img src="http://bj.bcebos.com/ibox-thumbnail98/e4efc0bd07c95f7a73c93470c5a6a47e?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T06%3A17%3A24Z%2F1800%2F%2F808c1723f016aac7c7f362aeea23a9e255a80e7188a45a51f4c470c1d52dfde6">

  * **read_request**:

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/f29665779776ae8ec6ac84214a191fc3?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T06%3A19%3A08Z%2F1800%2F%2F3d76dc414d9617dfb4a8c440df47e5d8c441e91e2e06fa4e0256e7c146271388">

  * **send_response**:

    > <img src="http://bj.bcebos.com/ibox-thumbnail98/3dbcb7586d83a21796d0206e7fb360db?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T06%3A24%3A18Z%2F1800%2F%2Fd9e093f8b52244a7e672958ca1f71f6be481297a4ed6b255fb0654b08bda1955">


## QueryContext介绍

> ref: [QueryContext介绍](http://wiki.baidu.com/pages/viewpage.action?pageId=207029551)

* 每个BaseModule的配套数据 = 进程数据ModBaseProcData + 检索环境ModBaseQueryContext（线程级变量数据）

* 每个QueryContext包含两个主要变量 = UpstreamData + ModBaseQueryContext数组

  * UpstreamData: 与下游交互数据的buffer变量
  * ModBaseQueryContext：数组大小与modules.conf定义的模块数一致
  
* 每个Searcher都维护一个检索环境池，每个线程一个QueryContext，每个QueryContext都维护多个Module的部分检索环境ModBaseQueryContext

  > 注意：每个Moduel的ModBaseQueryContext都会出现在所有线程中
  >
  > <img src="http://bj.bcebos.com/ibox-thumbnail98/8feb5bccc8e13c76d585df615169e672?authorization=bce-auth-v1%2Ffbe74140929444858491fbf2b6bc0935%2F2021-07-23T06%3A34%3A21Z%2F1800%2F%2Fe1d264e8c292a47a5ea92375792209fdc5999b093f0ca4c1f54f94fab61a5a1e">

* **QueryContext**
  
  >   数组大小 == module个数
  
  * 内存池：一次检索中所有的内存申请都会用到内存池
  * client端的send/recv buffer
  * 对象池
  * ModBaseQueryContext：存储Module各自的数据

