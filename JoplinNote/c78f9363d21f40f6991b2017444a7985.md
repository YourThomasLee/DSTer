数据结构

[TOC]
---
# 1. 经典结构
## 1.1\. 数组

## 1.2\. 链表

## 1.3\. 栈

## 1.4\. 树

### 1.4.1 二叉树的结构和遍历算法

```
//树的前序遍历进阶算法：morris遍历
/*
先序遍历：
1. 记录当前节点值到结果中
2. 有中序遍历前驱节点左移动（给前驱节点打上标记， 前驱节点->right=当前节点），如果标记已经存在， 什么也不做， 走3步骤
3. 没中序遍历前驱节点右移动
4. 重复2,3直到当前节点为空
后序遍历： 就是先序遍历结果的倒序
*/
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> res;
        if (root == nullptr) {
            return res;
        }
        TreeNode *p1 = root, *p2 = nullptr;
        while (p1 != nullptr) {
            p2 = p1->left;
            if (p2 != nullptr) {//找中序遍历前驱节点
                while (p2->right != nullptr && p2->right != p1) {
                    p2 = p2->right;
                }//中序遍历的前驱节点
                if (p2->right != p1) {//如果前驱的右子节点为空
                    res.emplace_back(p1->val);//把当前节点加入到结果中
                    p2->right = p1;//设定右节点为当前节点（打上跳过标记）
                    p1 = p1->left;
                    continue;
                } else if(p2->right == p1){//已经遍历过了
                    p2->right = nullptr;//删除标记
                    p1 = p1->right;
                }
            } else {
                res.emplace_back(p1->val);
                p1 = p1->right;
            }
        }
        return res;
    }
};
```

### 1.4.2 平衡二叉树



动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关

红黑树

### 1.4.3 多路查找树
为了提升随机查询的效率，平衡二叉树被提出尽可能地降低树高从而提升下查询效率。为了进一步提高查询效率，多路平衡树被提出来。
以下为正式的定义：
> A B-tree of order $m$ is a tree which satisfies the following properties:
> - every node has at most $m$ children
> - every non-leaf node (except root) has at least $\lceil m/2 \rceil$ children
> - the root has at least two children if it is not a leaf node
> - a non-leaf node with $k$ children contains $k-1$ keys
> - all leaves appear in the same level, and internal vertices carry no information



## 1.5\. 图

# 2. 计算几何

参考工作记录-东方晶源部分内容

id: c78f9363d21f40f6991b2017444a7985
parent_id: 80464764f5164c32aa2f63c67044fa09
created_time: 2023-03-29T06:32:26.760Z
updated_time: 2023-05-26T03:31:53.452Z
is_conflict: 0
latitude: 31.23041600
longitude: 121.47370100
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2023-03-29T06:32:26.760Z
user_updated_time: 2023-04-26T08:22:48.822Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
type_: 1