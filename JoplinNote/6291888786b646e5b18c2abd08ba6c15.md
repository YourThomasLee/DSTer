散列表

## 问题
许多应用都需要一种动态集合结构，它至少要支持三种操作（insert, search, delete)字典操作，散列表是实现字典操作的一种有效数据结构。
设我们要字典存储的元素的全域为$U = {0,1,\dots, m-1}$（如果存储的实际元素不是数值，设计一个转换方法将元素转换为数值，这里为了专门讨论hash，不对其他情况做考虑）
## 经典方法

### 直接寻址表
直接寻址将所有元素值直接一对一映射到数据结构的一个地址中，这种方法适用于全域数量较小的情况。优点是绝对不会有冲突，使得search效率为O(1)

### 散列表
直接寻址技术的缺点是：如果全域很大，使用该方法将耗费巨大的存储空间且通常情况下存储效率极低。在这样的一个背景下，我们在缩减存储空间的前提下，尽可能保证检索效率不下降。基于这样的一个考虑，散列表被提出。

散列表可以形式化为：$h: U \rightarrow \{0,\cdots, k\}$, 其中$k$要远远小于$|U| = m$, 从函数的角度上说，就是键到地址是多对一的关系，一个地址可以存储多个键，这提升了存储效率的同时，也提升了冲突(多个关键字到一个槽)的概率，这就引入了后续的冲突解决方法。
- 链接法：将一个槽的所有元素都放到一个双向链表中
- 开放寻址法： 

这里首先对链接法进行性能分析，这里假定数据结构是一个能存放n个元素，具有m个槽位的散列表$T$，定义$T$的装载因子$\alpha$，即是一个链的平均存储元素数。同时我们假定任何
- 最坏情况下，所有的$n$个关键字都散列到同一槽中，从而产生出一个长度为$n$的链表，这样查找的时间为$O(n)$
- 平均性能：

id: 6291888786b646e5b18c2abd08ba6c15
parent_id: 80464764f5164c32aa2f63c67044fa09
created_time: 2023-05-26T03:32:14.701Z
updated_time: 2023-05-29T06:58:38.244Z
is_conflict: 0
latitude: 31.23041600
longitude: 121.47370100
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2023-05-26T03:32:14.701Z
user_updated_time: 2023-05-29T06:58:38.244Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
type_: 1