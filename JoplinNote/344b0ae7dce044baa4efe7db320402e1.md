0. Introduction


## [Introduction](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/introduction.html) ^[[Official documents of Boost.Geometry](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/index.html)]

Boost.Geometry (aka Generic Geometry Library, GGL), part of collection of the Boost C++ Libraries, defines concepts, primitives and algorithms for solving geometry problems.

Boost.Geometry contains a dimension-agnostic, coordinate-system-agnostic and scalable kernel, based on concepts, meta-functions and tag dispatching. On top of that kernel, algorithms are built: area, length, perimeter, centroid, convex hull, intersection (clipping), within (point in polygon), distance, envelope (bounding box), simplify, transform, and much more. The library supports high precision arithmetic numbers, such as ttmath.

Boost.Geometry contains instantiable geometry classes, but library users can also use their own. Using registration macros or traits classes their geometries can be adapted to fulfil Boost.Geometry concepts.

Boost.Geometry might be used in all domains where geometry plays a role: mapping and GIS, game development, computer graphics and widgets, robotics, astronomy and more. The core is designed to be as generic as possible and support those domains. For now, the development has been mostly GIS-oriented.

The library follows existing conventions:

- conventions from boost
- conventions from the std library
- conventions and names from one of the OGC standards on geometry and, more specificly, from the [OGC Simple Feature Specification](http://www.opengeospatial.org/standards/sfa)

The process of compilation can be found at [page](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/compilation.html), you can check it when you come across an obstacle in compilation.

## [Design rationale](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/design.html#geometry.design.dimension_agnosticism)

Suppose you need a C++ program to calculate the distance between two points. You might define a struct:

```C++
struct mypoint
{
    double x, y;
};
```

and a function, containing the algorithm:

```C++
double distance(mypoint const& a, mypoint const& b)
{
    double dx = a.x - b.x;
    double dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
}
```

Quite simple, and it is usable, but not generic. For a library it has to be designed way further. The design above can only be used for 2D points, for the struct mypoint (and no other struct), in a Cartesian coordinate system. A generic library should be able to calculate the distance:

- for any point class or struct, not on just this mypoint type
    in more than two dimensions
- for other coordinate systems, e.g. over the earth or on a sphere
    between a point and a line or between other geometry combinations
    in higher precision than double
- avoiding the square root: often we don't want to do that because it is a relatively expensive function, and for comparing distances it is not necessary

In this and following sections we will make the design step by step more generic.

- Using templates for simplification of types of data
	```C++
	template <typename P1, typename P2>
	double distance(P1 const& a, P2 const& b)
	{
		double dx = a.x - b.x;
		double dy = a.y - b.y;
		return std::sqrt(dx * dx + dy * dy);
	}
	```
- Using traits system to allow any point type as input and do not directly access to x and y members. The function then becomes:
	```C++
	template <typename P1, typename P2>
	double distance(P1 const& a, P2 const& b)
	{
		double dx = get<0>(a) - get<0>(b);
		double dy = get<1>(a) - get<1>(b);
		return std::sqrt(dx * dx + dy * dy);
	}
	```
	the traits system is defined as following:
	```C++
	namespace traits
	{
		template <typename P, int D>
		struct access {};
	}
	```
	which is then specialized for our mypoint type, implementing a static method called get
	```C++
	namespace traits
	{
		template <>
		struct access<mypoint, 0>
		{
			static double get(mypoint const& p)
			{
				return p.x;
			}
		};
		// same for 1: p.y
		...
	}
	```
	Calling traits::access<mypoint, 0>::get(a) now returns us our x coordinate. It is too verbose for a function like this, used so often in the library. We can shorten the syntax by adding an extra free function:
	```C++
	template <int D, typename P>
	inline double get(P const& p)
	{
		return traits::access<P, D>::get(p);
	}
	```
	This enables us to call get<0>(a), for any point having the traits::access specialization, as shown in the distance algorithm at the start of this paragraph. 
- Dimension agnosticism: 

https://blog.csdn.net/QQ2558030393/article/details/94565537

#TODO

## [Basic concepts](https://blog.csdn.net/yanfeng1022/article/details/100000741)

In the library Boost.Geometry, following concepts are very common and important^[[CSDN boost.geometry学习笔记](https://blog.csdn.net/yanfeng1022/article/details/100000741)].
- [boost::geometry::model::point](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/reference/models/model_point.html) => Basic point calss, having coordingates defined in a natural way
- [boost::geometry::model::linestring](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/reference/models/model_linestring.html) => A linestring (named so by OGC) is a collection (default a vector) of points.
- [boost::geometry::model::polygon](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/reference/models/model_polygon.html) => The polygon contains an outer ring and zero or more inner rings.
-  [boost::geometry::model::box](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/reference/models/model_box.html) => Class box: defines a box made of two describing points. Box is always described by a min_corner() and a max_corner() point. If another rectangle is used, use linear_ring or polygon.
-  [boost::geometry::model::segment](https://www.boost.org/doc/libs/1_69_0/libs/geometry/doc/html/geometry/reference/models/model_segment.html) => Class segment: small class containing two points. From Wikipedia: In geometry, a line segment is a part of a line that is bounded by two distinct end points, and contains every point on the line between its end points.


## Spatial index^[Boost.Geometry R\*树，[web page](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/geometry/spatial_indexes/introduction.html)]

The R-tree structure is presented on the image below. Each R-tree's node store a box describing the space occupied by its children nodes. At the bottom of the structure, there are leaf-nodes which contains values (geometric objects representations).
function despcription:  It was proposed by Antonin Guttman in 1984 ^[Guttman, A. (1984). R-Trees: A Dynamic Index Structure for Spatial Searching] as an expansion of B-tree for multi-dimensional data. It may be used to store points or volumetric data in order to perform a spatial query. This query may for example return objects that are inside some area or are close to some point in space ^[Cheung, K.; Fu, A. (1998). Enhanced Nearest Neighbour Search on the R-tree]. It's possible to insert new objects or to remove the ones already stored.
![R-tree](https://www.boost.org/doc/libs/1_81_0/libs/geometry/doc/html/img/index/rtree/rstar.png)
The R-tree is a self-balanced data structure. The key part of balancing algorithm is node splitting algorithm ^[Greene, D. (1989). An implementation and performance analysis of spatial data access methods] ^[Beckmann, N.; Kriegel, H. P.; Schneider, R.; Seeger, B. (1990). The R*-tree: an efficient and robust access method for points and rectangles]. In general, more complex algorithms analyses elements better and produces less overlapping nodes. In the searching process less nodes must be traversed in order to find desired objects. On the other hand more complex analysis takes more time. In general faster inserting will result in slower searching and vice versa. The performance of the R-tree depends on balancing algorithm, parameters and data inserted into the container.

Additionally there are also algorithms creating R-tree containing some, number of objects. This technique is called bulk loading and is done by use of packing algorithm ^[Leutenegger, Scott T.; Edgington, Jeffrey M.; Lopez, Mario A. (1997). STR: A Simple and Efficient Algorithm for R-Tree Packing] ^[Garcia, Yvan J.; Lopez, Mario A.; Leutenegger, Scott T. (1997). A Greedy Algorithm for Bulk Loading R-trees].




id: 344b0ae7dce044baa4efe7db320402e1
parent_id: fa2633056cee46aa84bc6cac7aea9c87
created_time: 2023-04-04T06:11:13.976Z
updated_time: 2023-04-10T08:37:43.821Z
is_conflict: 0
latitude: 31.23041600
longitude: 121.47370100
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2023-04-04T06:11:13.976Z
user_updated_time: 2023-04-10T08:37:43.821Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
type_: 1