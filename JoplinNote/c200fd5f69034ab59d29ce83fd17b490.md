id: c200fd5f69034ab59d29ce83fd17b490
parent_id: c0894e5d5e08471bbbe1d4013d73d11a
item_type: 1
item_id: e13c144c10154b94b534fdf7d7c15d57
item_updated_time: 1685071909695
title_diff: "[{\"diffs\":[[1,\"传统算法\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":4}]"
body_diff: "[{\"diffs\":[[1,\"目录\\\n[TOC]\\\n---\\\n\\\n必备的一些基础算法： 查找算法（线性查找算法，二分查找算法），排序算法，递归和迭代算法， 动态规划， 位操作算法， 概率算法， 排列组合算法， 朴素贝叶斯分类算法\\\n\\\n## 1\\\\. 查找\\\n\\\n二分查找\\\n\\\n```\\\nint binSearch(vector<int>& arr, int val){\\\n    int l = 0, r = arr.size() - 1, m = 0;\\\n    while(l < r){\\\n        m = (r - l) / 2 + l;\\\n        if(arr[m] > val) r = m - 1;\\\n        else if(arr[m] == val) return m;\\\n        else if(arr[m] < val) l = m + 1;\\\n    }\\\n    return -1;\\\n}\\\n```\\\n\\\n## 2\\\\. 排序\\\n\\\n排序算法如下：\\\n\\\n![image.png](:/501b79b7fe5e40618f17b0e4bf4aed54)\\\n\\\n详细的复杂度：\\\n\\\n![image.png](:/baf972160c8d4dfea336ec092582bb6a)\\\n\\\n冒泡排序：\\\n\\\n```\\\ntemplate<typename T> \\\nvoid bubble_sort(T arr[], int len) {\\\n        int i, j;\\\n        for (i = 0; i < len - 1; i++)\\\n                for (j = 0; j < len - 1 - i; j++)\\\n                        if (arr[j] > arr[j + 1])\\\n                                swap(arr[j], arr[j + 1]);\\\n}\\\n```\\\n\\\n选择排序：\\\n\\\n```\\\ntemplate<typename T> \\\nvoid selection_sort(std::vector<T>& arr) {\\\n        for (int i = 0; i < arr.size() - 1; i++) {\\\n                int min = i;\\\n                for (int j = i + 1; j < arr.size(); j++)\\\n                        if (arr[j] < arr[min])\\\n                                min = j;\\\n                std::swap(arr[i], arr[min]);\\\n        }\\\n}\\\n```\\\n\\\n插入排序：\\\n\\\n```\\\nvoid insertion_sort(int arr[],int len){\\\n        for(int i=1;i<len;i++){\\\n                int key=arr[i];\\\n                int j=i-1;\\\n                while((j>=0) && (key<arr[j])){\\\n                        arr[j+1]=arr[j];\\\n                        j--;\\\n                }\\\n                arr[j+1]=key;\\\n        }\\\n}\\\n```\\\n\\\n希尔排序：\\\n\\\n```\\\ntemplate <typename _RIter>\\\nvoid insert_sort(_RIter st, _RIter ed, int delta) {\\\n    for(_RIter i = st + delta; i < ed; i += delta) {//i为构造的有序区右边界\\\n        for(_RIter j = i; j > st; j -= delta)//遍历组内所有元素，构造新的有序区\\\n            if(*j < *(j - delta)) std::swap(*j, *(j - delta));\\\n            else break;\\\n    }\\\n}\\\n \\\ntemplate <typename _RIter>\\\nvoid shell_sort(_RIter st, _RIter ed) {\\\n    for(int delta = ed - st; delta; delta >>= 1)//分组,每组长度delta， delta由大到小\\\n        for(int i = 0; i < delta; i++)//遍历所有分组\\\n            insert_sort(st + i, ed, delta);//组内排序\\\n}\\\n```\\\n\\\n归并排序：\\\n\\\n```\\\nvoid mergeSort(vector<int>& nums, int l, int r) {\\\n        if (l >= r) return;\\\n        int mid = (l + r) >> 1;\\\n        mergeSort(nums, l, mid);\\\n        mergeSort(nums, mid + 1, r);\\\n        int i = l, j = mid + 1;\\\n        int cnt = 0;\\\n        while (i <= mid && j <= r) {\\\n            if (nums[i] <= nums[j]) {\\\n                tmp[cnt++] = nums[i++];\\\n            }\\\n            else {\\\n                tmp[cnt++] = nums[j++];\\\n            }\\\n        }\\\n        while (i <= mid) {\\\n            tmp[cnt++] = nums[i++];\\\n        }\\\n        while (j <= r) {\\\n            tmp[cnt++] = nums[j++];\\\n        }\\\n        for (int i = 0; i < r - l + 1; ++i) {\\\n            nums[i + l] = tmp[i];\\\n        }\\\n```\\\n\\\n快速排序：\\\n\\\n```\\\nclass Solution {\\\n    int partition(vector<int>& nums, int l, int r) {\\\n        int pivot = nums[r];\\\n        int i = l - 1;\\\n        for (int j = l; j <= r - 1; ++j) {\\\n            if (nums[j] <= pivot) {\\\n                i = i + 1;\\\n                swap(nums[i], nums[j]);\\\n            }\\\n        }\\\n        swap(nums[i + 1], nums[r]);\\\n        return i + 1;\\\n    }\\\n    int randomized_partition(vector<int>& nums, int l, int r) {\\\n        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元\\\n        swap(nums[r], nums[i]);\\\n        return partition(nums, l, r);\\\n    }\\\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\\\n        if (l < r) {\\\n            int pos = randomized_partition(nums, l, r);\\\n            randomized_quicksort(nums, l, pos - 1);\\\n            randomized_quicksort(nums, pos + 1, r);\\\n        }\\\n    }\\\npublic:\\\n    vector<int> sortArray(vector<int>& nums) {\\\n        srand((unsigned)time(NULL));\\\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\\\n        return nums;\\\n    }\\\n};\\\n```\\\n\\\n堆排序：\\\n\\\n```\\\nvoid maxHeapify(vector<int>& nums, int i, int len) {\\\n        for (; (i << 1) + 1 <= len;) {\\\n            int lson = (i << 1) + 1;\\\n            int rson = (i << 1) + 2;\\\n            int large;\\\n            if (lson <= len && nums[lson] > nums[i]) {\\\n                large = lson;\\\n            } else {\\\n                large = i;\\\n            }\\\n            if (rson <= len && nums[rson] > nums[large]) {\\\n                large = rson;\\\n            }\\\n            if (large != i) {\\\n                swap(nums[i], nums[large]);\\\n                i = large;\\\n            } else {\\\n                break;\\\n            }\\\n        }\\\n    }\\\n    void buildMaxHeap(vector<int>& nums, int len) {\\\n        for (int i = len / 2; i >= 0; --i) {\\\n            maxHeapify(nums, i, len);\\\n        }\\\n    }\\\n    void heapSort(vector<int>& nums) {\\\n        int len = (int)nums.size() - 1;\\\n        buildMaxHeap(nums, len);\\\n        for (int i = len; i >= 1; --i) {\\\n            swap(nums[i], nums[0]);\\\n            len -= 1;\\\n            maxHeapify(nums, 0, len);\\\n        }\\\n    }\\\n```\\\n\\\n计数排序：哈希拉链，然后统计比自己小的数的个数，适用于范围小密度高的数据\\\n\\\n```\\\nvoid counting_sort(int *ini_arr, int *sorted_arr, int n) {\\\n        int *count_arr = (int *) malloc(sizeof(int) * 100);\\\n        int i, j, k;\\\n        for (k = 0; k < 100; k++)\\\n                count_arr[k] = 0;\\\n        for (i = 0; i < n; i++)\\\n                count_arr[ini_arr[i]]++;\\\n        for (k = 1; k < 100; k++)\\\n                count_arr[k] += count_arr[k - 1];\\\n        for (j = n; j > 0; j--)\\\n                sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];\\\n        free(count_arr);\\\n}\\\n```\\\n\\\n桶排序: 计数排序拉链可能很长，耗费空间，由此设计哈希将数据分桶（一般是一个桶对应一个区间，这样桶之间数据合并方便），每个桶内排序完再合并\\\n\\\n基数排序：适用于整型\\\n\\\n```\\\nint maxbit(int data[], int n) //辅助函数，求数据的最大位数 {\\\n    int maxData = data[0];              ///< 最大数\\\n    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。\\\n    for (int i = 1; i < n; ++i)\\\n    {\\\n        if (maxData < data[i])\\\n            maxData = data[i];\\\n    }\\\n    int d = 1;\\\n    int p = 10;\\\n    while (maxData >= p)\\\n    {\\\n        //p *= 10; // Maybe overflow\\\n        maxData /= 10;\\\n        ++d;\\\n    }\\\n    return d;\\\n/*    int d = 1; //保存最大的位数\\\n    int p = 10;\\\n    for(int i = 0; i < n; ++i)\\\n    {\\\n        while(data[i] >= p)\\\n        {\\\n            p *= 10;\\\n            ++d;\\\n        }\\\n    }\\\n    return d;*/\\\n}\\\nvoid radixsort(int data[], int n) //基数排序 {\\\n    int d = maxbit(data, n);\\\n    int *tmp = new int[n];\\\n    int *count = new int[10]; //计数器\\\n    int i, j, k;\\\n    int radix = 1;\\\n    for(i = 1; i <= d; i++) //进行d次排序\\\n    {\\\n        for(j = 0; j < 10; j++)\\\n            count[j] = 0; //每次分配前清空计数器\\\n        for(j = 0; j < n; j++)\\\n        {\\\n            k = (data[j] / radix) % 10; //统计每个桶中的记录数\\\n            count[k]++;\\\n        }\\\n        for(j = 1; j < 10; j++)\\\n            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶\\\n        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中\\\n        {\\\n            k = (data[j] / radix) % 10;\\\n            tmp[count[k] - 1] = data[j];\\\n            count[k]--;\\\n        }\\\n        for(j = 0; j < n; j++) //将临时数组的内容复制到data中\\\n            data[j] = tmp[j];\\\n        radix = radix * 10;\\\n    }\\\n    delete []tmp;\\\n    delete []count;\\\n}\\\n```\\\n\\\n## hash 算法\\\n```C++\\\ntypedef unsigned long long HashCode;\\\n\\\n//Thomas Wong's\\\ninline __host__ __device__ HashCode int64_hash(HashCode code)\\\n{\\\n    code += ~(code << 32);\\\n    code ^= (code >> 22);\\\n    code += ~(code << 13);\\\n    code ^= (code >> 8);\\\n    code += (code << 3);\\\n    code ^= (code >> 15);\\\n    code += ~(code << 27);\\\n    code ^= (code >> 31);\\\n    return code;\\\n}\\\n#endif\\\n\\\n```\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":7268}]"
metadata_diff: {"new":{"id":"e13c144c10154b94b534fdf7d7c15d57","parent_id":"70beb724b53f4c47823db93c7d479823","latitude":"31.23041600","longitude":"121.47370100","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":"","user_updated_time":1684486648892},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-05-26T03:39:25.670Z
created_time: 2023-05-26T03:39:25.670Z
type_: 13