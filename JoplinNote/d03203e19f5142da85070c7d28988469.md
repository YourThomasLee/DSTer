id: d03203e19f5142da85070c7d28988469
parent_id: 771f352310ff4f5994a5f51ec1b7a865
item_type: 1
item_id: f776a63ec57041ddbafd7b930a020c2d
item_updated_time: 1687339609183
title_diff: "[{\"diffs\":[[1,\"3. C++ 程序设计\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":11}]"
body_diff: "[{\"diffs\":[[1,\"# C++ 概论\\\n## 0. 基础语法说明\\\n\\\n- const: 声明常量。非静态类成员函数后面可以放const用来限制对\\\"this, \\\\*this(类成员)\\\"两个变量的修改（这表明const修饰this和\\\\*this是和static冲突的），这里不能被修改的成员不包括被mutable修饰的成员。另外对于加了const修饰的成员函数刻以被非const对象和const对象调用，但不加const的成员函数只能被非const对象调用；const放在函数前面表明返回值为const变量；\\\n\\\n- typedef： C语言关键字，主要的作用是定义机器无关的类型，使得代码具备平台可移植性。在传统的变量声明表达式里，用（新的）类型名替换变量名。例如定义`typdef long double REAL;`那么在不支持long double的机器上运行相关代码只需要修改对应的typedef语句`typedef double REAL;`即可。复杂一些的是函数的typedef： `typedef void (*PFUNA)(int a); ` 给一个类型的函数起了别名。\\\n\\\n二、define中的三个特殊符号：#，##，#@\\\n\\\n#define Conn(x,y) x##y\\\n#define ToChar(x) #@x\\\n#define ToString(x) #x\\\n(1)x##y表示什么？表示x连接y，举例说：\\\n\\\nint n = Conn(123,456); /* 结果就是n=123456;*/\\\nchar* str = Conn(\\\"asdf\\\", \\\"adf\\\"); /*结果就是 str = \\\"asdfadf\\\";*/\\\n（2）再来看，其实就是给x加上单引号，结果返回是一个const char。举例说：\\\n\\\nchar a = ToChar(1);结果就是a='1';\\\n\\\n做个越界试验char a = ToChar(123);结果就错了;\\\n\\\n但是如果你的参数超过四个字符，编译器就给给你报错了！\\\n\\\nerror C2015: too many characters in constant ：P\\\n\\\n(3）最后看看#x,估计你也明白了，他是给x加双引号\\\n\\\nchar* str = ToString(123132);就成了str=\\\"123132\\\";\\\n\\\n三、常用的一些宏定义\\\n\\\n1 防止一个头文件被重复包含\\\n\\\n#ifndef BODYDEF_H\\\n#define BODYDEF_H\\\n//头文件内容\\\n#endif\\\n2 得到指定地址上的一个字节或字\\\n\\\n#define MEM_B( x ) ( *( (byte *) (x) ) )\\\n#define MEM_W( x ) ( *( (word *) (x) ) )\\\n用法如下：\\\n```C++\\\n#include <iostream>\\\n#include <windows.h>\\\n#define MEM_B(x) (*((byte*)(x)))\\\n#define MEM_W(x) (*((WORD*)(x)))\\\nint main()\\\n{\\\nint bTest = 0x123456;\\\nbyte m = MEM_B((&bTest));/*m=0x56*/\\\nint n = MEM_W((&bTest));/*n=0x3456*/\\\nreturn 0;\\\n}\\\n```\\\n3 得到一个field在结构体(struct)中的偏移量\\\n\\\n#define OFFSETOF( type, field ) ( (size_t) &(( type *) 0)-> field )\\\n请参考文章：[详解写宏定义：得到一个field在结构体（struct type）中的偏移量。](https://www.cnblogs.com/zhangjianlaoda/p/4356835.html)\\\n\\\n4 得到一个结构体中field所占用的字节数\\\n\\\n#define FSIZ( type, field ) sizeof( ((type *) 0)->field )\\\n5 得到一个变量的地址（word宽度）\\\n\\\n#define B_PTR( var ) ( (byte *) (void *) &(var) )\\\n#define W_PTR( var ) ( (word *) (void *) &(var) )\\\n6 将一个字母转换为大写\\\n\\\n#define UPCASE( c ) ( ((c) >= ''a'' && (c) <= ''z'') ? ((c) - 0x20) : (c) )\\\n7 判断字符是不是10进值的数字\\\n\\\n#define DECCHK( c ) ((c) >= ''0'' && (c) <= ''9'')\\\n8 判断字符是不是16进值的数字\\\n\\\n#define HEXCHK( c ) ( ((c) >= ''0'' && (c) <= ''9'') ||((c) >= ''A'' && (c) <= ''F'') ||((c) >= ''a'' && (c) <= ''f'') )\\\n9 防止溢出的一个方法\\\n\\\n#define INC_SAT( val ) (val = ((val)+1 > (val)) ? (val)+1 : (val))\\\n10 返回数组元素的个数\\\n\\\n#define ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )\\\n11 使用一些宏跟踪调试\\\n\\\nANSI标准说明了五个预定义的宏名。它们是：\\\n\\\n_LINE_ /*(两个下划线)，对应%d*/\\\n_FILE_ /*对应%s*/\\\n_DATE_ /*对应%s*/\\\n_TIME_ /*对应%s*/\\\n\\\n## 1. C++ 数据类型\\\n\\\n## 2. 数据结构\\\n\\\n## 3. 函数\\\n\\\n## 4. 高级用法\\\n\\\n\\\n\\\n\\\n\"]],\"start1\":0,\"start2\":0,\"length1\":0,\"length2\":2405}]"
metadata_diff: {"new":{"id":"f776a63ec57041ddbafd7b930a020c2d","parent_id":"5c2f695eacaa45358e6c9c5e1baaf6e7","latitude":"31.23041600","longitude":"121.47370100","altitude":"0.0000","author":"","source_url":"","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0,"share_id":"","conflict_original_id":"","master_key_id":""},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2023-06-21T09:29:34.386Z
created_time: 2023-06-21T09:29:34.386Z
type_: 13